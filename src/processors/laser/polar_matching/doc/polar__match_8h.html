<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>PolarScanMatching(PSM): polar_matching/polar_match.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>polar_matching/polar_match.h File Reference</h1><code>#include &lt;stdio.h&gt;</code><br>

<p>
<a href="polar__match_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPMScan.html">PMScan</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Structure describing a laser scan.  <a href="structPMScan.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#1f1545ae657e3e45bd93e57f9df9a774">PM_PSD_SCANNER</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#88446d4afac7a19b554b1ef7351e00d5">PM_HOKUYO_URG_04LX</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#34dcc5c7fb9c2ee19db0e8441b353b0c">PM_SICK_LMS200</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#20c80bf5ce369e4af70df4bc86991b27">PM_HOKUYO_UTM_30LX</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#b5589c1a2ace1e70b8e33f42111c11c0">PM_LASER</a>&nbsp;&nbsp;&nbsp;PM_HOKUYO_UTM_30LX</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#6fc025e7dda64669c01c2742b377e7bb">PM_LASER_NAME</a>&nbsp;&nbsp;&nbsp;&quot;HOKUYO UTM-30LX&quot;</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The name of the laser range finder.  <a href="#6fc025e7dda64669c01c2742b377e7bb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#fbd71471c9ea93ba0bdef75c051cb261">PM_L_POINTS</a>&nbsp;&nbsp;&nbsp;1081</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum number of points in a scan.  <a href="#fbd71471c9ea93ba0bdef75c051cb261"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#9e29b0d21c905b7aa10cebcd439f1a8b">PM_FOV</a>&nbsp;&nbsp;&nbsp;270</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Field of view of the laser range finder in degrees.  <a href="#9e29b0d21c905b7aa10cebcd439f1a8b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#ddeab933b14db8ee4ec85c5001e9e1b6">PM_MAX_RANGE</a>&nbsp;&nbsp;&nbsp;700</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[cm] Maximum valid laser range. (3000 for this sensor.)  <a href="#ddeab933b14db8ee4ec85c5001e9e1b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#5f67e7016ad1a22a1b3d3d4c3a2daf09">PM_MIN_VALID_POINTS</a>&nbsp;&nbsp;&nbsp;300</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Minimum number of valid points for scan matching.  <a href="#5f67e7016ad1a22a1b3d3d4c3a2daf09"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#c91b4de7ae597b94bcec1c4e42e45e4a">PM_SEARCH_WINDOW</a>&nbsp;&nbsp;&nbsp;200</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Half window size which is searched for correct orientation.  <a href="#c91b4de7ae597b94bcec1c4e42e45e4a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#12ef0a402ef7b41d2c9fc743d6323aa2">PM_CORRIDOR_THRESHOLD</a>&nbsp;&nbsp;&nbsp;25.0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Threshold for angle variation between points to determine if scan was taken of a corridor.  <a href="#12ef0a402ef7b41d2c9fc743d6323aa2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#f1bad4201ab86ef3744a85d53b2ded50">PM_TIME_DELAY</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[s] Time delay (time registration error) in the laser measurements. Use 0.02 for SLAMbot.  <a href="#f1bad4201ab86ef3744a85d53b2ded50"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#cb686990f0e3ce35b264c05c9062b63a">PM_LASER_Y</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[cm] Y coordinate of the laser on the robot.  <a href="#cb686990f0e3ce35b264c05c9062b63a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#79987f669fd90361ff94eaf778709f37">PM_MIN_RANGE</a>&nbsp;&nbsp;&nbsp;10.0f</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[cm] Minimum valid laser range for the reprojected current scan.  <a href="#79987f669fd90361ff94eaf778709f37"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#d5632a2b540e35319931ca7d0e2170a0">PM_SEG_MAX_DIST</a>&nbsp;&nbsp;&nbsp;20.0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The distance between points to break a segment.  <a href="#d5632a2b540e35319931ca7d0e2170a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#ee30602d40d89456b33d224ba8646f86">PM_WEIGHTING_FACTOR</a>&nbsp;&nbsp;&nbsp;70*70</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Parameter used for weighting associated points in the position calculation of PSM. Try setting it to 30*30 for laser odometry.  <a href="#ee30602d40d89456b33d224ba8646f86"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#e672ca4e6355c247d2374b08c9985b0a">PM_CHANGE_WEIGHT_ITER</a>&nbsp;&nbsp;&nbsp;10</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of iterations after which the weighting factor is reduced to weight down outliers.  <a href="#e672ca4e6355c247d2374b08c9985b0a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#d51e4b68f66ac8b34eb967900cf88254">PM_TYPE</a>&nbsp;&nbsp;&nbsp;float</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The variable type used in calculations. Change it to double for higher accuracy and lower speed.  <a href="#d51e4b68f66ac8b34eb967900cf88254"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#ac716ccdca73689fc1d4d29117c6d816">PM_MAX_ERROR</a>&nbsp;&nbsp;&nbsp;100</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[cm] Maximum distance between associated points used in pose estimation. Try setting it to 30 for laser odometry.  <a href="#ac716ccdca73689fc1d4d29117c6d816"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#9455b77f912bb1a02edd45dec9481546">PM_STOP_COND</a>&nbsp;&nbsp;&nbsp;0.4</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If the pose change (|dx|+|dy|+|dth|) is smaller than this PSM scan matching stops.  <a href="#9455b77f912bb1a02edd45dec9481546"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#24a5a1c6ca5fc964a95f9c8d66321a1c">PM_MAX_ITER</a>&nbsp;&nbsp;&nbsp;30</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum number of iterations for PSM.  <a href="#24a5a1c6ca5fc964a95f9c8d66321a1c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#0989a364bb66d542863ebea24374be59">PM_MAX_ITER_ICP</a>&nbsp;&nbsp;&nbsp;60</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum number of iterations for ICP.  <a href="#0989a364bb66d542863ebea24374be59"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#1e71013204bc565a4b62a6a47926c2a8">PM_STOP_COND_ICP</a>&nbsp;&nbsp;&nbsp;0.1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stopping condition for ICP. The pose change has to be smaller than this.  <a href="#1e71013204bc565a4b62a6a47926c2a8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#749734da50c3898c95b6570472fcdd84">PM_MIN_STD_XY</a>&nbsp;&nbsp;&nbsp;20.0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[cm] The minimum match result standard deviation in X or Y direction. Used in covariance estimation.  <a href="#749734da50c3898c95b6570472fcdd84"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#e44b85502998a44b561543470ecd14d0">PM_MIN_STD_ORIENTATION</a>&nbsp;&nbsp;&nbsp;4.0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[degrees] The minimum standard deviation of the orientation match. Used in covariance estimation.  <a href="#e44b85502998a44b561543470ecd14d0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#127cb0f2f4998aa37f8193aa6804d58c">PM_MATCH_ERROR_OFFSET</a>&nbsp;&nbsp;&nbsp;5.0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">[cm] Offset subtracted from average range residual when scaling the covariance matrix.  <a href="#127cb0f2f4998aa37f8193aa6804d58c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#1b47ca281afd6f25bd2a0536090a073b">PM_ODO</a>&nbsp;&nbsp;&nbsp;-1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Show results with odometry only in mapping_with_matching().  <a href="#1b47ca281afd6f25bd2a0536090a073b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#ef58bcd878269c2d222a0ecc2ec5232d">PM_PSM</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Polar scan matching - matching bearing association rule.  <a href="#ef58bcd878269c2d222a0ecc2ec5232d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#8d5edbed38016249ada2530b04d7db88">PM_ICP</a>&nbsp;&nbsp;&nbsp;3</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Scan matching with iterative closest point association rule.  <a href="#8d5edbed38016249ada2530b04d7db88"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#d3a56b8761c758c51c32c5b869f9c17b">PM_TIME_FILE</a>&nbsp;&nbsp;&nbsp;&quot;results/iterations.txt&quot;</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">When generating results, timing is data is saved into this file from the matching algorithms. i|time|ax|ay|ath[deg] is saved. Does not work in the moment.  <a href="#d3a56b8761c758c51c32c5b869f9c17b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#57fe2d06df1606362b8af182164f1ca3">PM_RANGE</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Measurement tag: range reading is longer than PM_MAX_RANGE.  <a href="#57fe2d06df1606362b8af182164f1ca3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#9b68094f2b71d03bdfb392053de3e037">PM_MOVING</a>&nbsp;&nbsp;&nbsp;2</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Measurement tag: range reading corresponds to a moving point. Not implemented yet.  <a href="#9b68094f2b71d03bdfb392053de3e037"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#9c63390241a1996a375113e70818480f">PM_MIXED</a>&nbsp;&nbsp;&nbsp;4</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Measurement tag: range reading is a mixed pixel.  <a href="#9c63390241a1996a375113e70818480f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#514dcb3d8e039386047654eb3de7b4f8">PM_OCCLUDED</a>&nbsp;&nbsp;&nbsp;8</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Measurement tag: range reading is occluded.  <a href="#514dcb3d8e039386047654eb3de7b4f8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#7c8557515b1efc22da1f066ea3f539f1">PM_EMPTY</a>&nbsp;&nbsp;&nbsp;16</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Measurement tag: no measurment (between 2 segments there is no interpolation!).  <a href="#7c8557515b1efc22da1f066ea3f539f1"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#4947dafdc94654327c5205bddfa001dd">pm_init</a> (const char *filename=NULL, FILE **fin=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialises internal variables and opens a log file.  <a href="#4947dafdc94654327c5205bddfa001dd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#f0959739b175ea5bee403844ec8fe348">pm_readScan</a> (FILE *fin, <a class="el" href="structPMScan.html">PMScan</a> *ls)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads one scan from file <em>fin</em> and stores it in <em>ls</em>.  <a href="#f0959739b175ea5bee403844ec8fe348"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#da0c2b85d87b32706c919c721d8a7553">pm_save_scan</a> (<a class="el" href="structPMScan.html">PMScan</a> *act, const char *filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Saves scan in a text file.  <a href="#da0c2b85d87b32706c919c721d8a7553"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#748e87f2c5ded82e517d1bcd9fc7322b">pm_preprocessScan</a> (<a class="el" href="structPMScan.html">PMScan</a> *ls)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepares a scan for scan matching.  <a href="#748e87f2c5ded82e517d1bcd9fc7322b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#a84d80a545d2ec2b25bdf2a6bfa5a862">pm_psm</a> (const <a class="el" href="structPMScan.html">PMScan</a> *lsr, <a class="el" href="structPMScan.html">PMScan</a> *lsa)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match two laser scans using polar scan matching.  <a href="#a84d80a545d2ec2b25bdf2a6bfa5a862"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#18792f0a29282b0365341e80ceb46681">pm_icp</a> (const <a class="el" href="structPMScan.html">PMScan</a> *lsr, <a class="el" href="structPMScan.html">PMScan</a> *lsa)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Matches two laser scans using the iterative closest point method.  <a href="#18792f0a29282b0365341e80ceb46681"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#0e95edd6e41d0087202f9fadbc8ad396">pm_plotScanAt</a> (const <a class="el" href="structPMScan.html">PMScan</a> *ls, PM_TYPE x, PM_TYPE y, PM_TYPE th, const char *col, double diameter=2.0, bool connect_lines=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plots scan <em>ls</em> at robot/laser pose <em>x</em>, <em>y</em>, <em>th</em>.  <a href="#0e95edd6e41d0087202f9fadbc8ad396"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#f9679379fd1436aff93ab8b4813983f4">pm_plotScan</a> (<a class="el" href="structPMScan.html">PMScan</a> *ls, const char *col, double diameter=2.0, bool connect_lines=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plots scan <em>ls</em>.  <a href="#f9679379fd1436aff93ab8b4813983f4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#09ec80e246f96fea1d9384164824c8a3">pm_show_segmentation</a> (const <a class="el" href="structPMScan.html">PMScan</a> *ls)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shows segmentation results by plotting segments with different colours.  <a href="#09ec80e246f96fea1d9384164824c8a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#22eabc3feff28cd8fd8fb19571e6b675">pm_plotScan4Thesis</a> (<a class="el" href="structPMScan.html">PMScan</a> *lsr, <a class="el" href="structPMScan.html">PMScan</a> *lsa)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plots current and reference scan in the way scans appeared in my thesis.  <a href="#22eabc3feff28cd8fd8fb19571e6b675"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#cb70907d3ce433306298dbef5641bc64">pm_plotTime4Thesis</a> (PM_TYPE xt, PM_TYPE yt, PM_TYPE tht, int *iter=NULL, double *time=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates a convergence speed plot from previously saved result.  <a href="#cb70907d3ce433306298dbef5641bc64"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#af222f8943373c7a4a0bbc8f69d6fd72">pm_is_corridor</a> (<a class="el" href="structPMScan.html">PMScan</a> *act)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Guesses if a scan was taken on a corridor.  <a href="#af222f8943373c7a4a0bbc8f69d6fd72"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#90a35f8730af8bf63851a685506764ff">pm_error_index</a> (<a class="el" href="structPMScan.html">PMScan</a> *lsr, <a class="el" href="structPMScan.html">PMScan</a> *lsa)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates an error index expressing the quality of a match.  <a href="#90a35f8730af8bf63851a685506764ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#afb41ec02d1003d39e2feabd15827a4a">pm_error_index2</a> (<a class="el" href="structPMScan.html">PMScan</a> *ref, <a class="el" href="structPMScan.html">PMScan</a> *cur, int *associatedPoints=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">More quickly calculates an error index expressing the quality of a match.  <a href="#afb41ec02d1003d39e2feabd15827a4a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#269e637afa67455e2a281485c2132cd1">pm_corridor_angle</a> (<a class="el" href="structPMScan.html">PMScan</a> *act)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines the orientation of a corridor.  <a href="#269e637afa67455e2a281485c2132cd1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#29790780aad473173713c4c4761e55fe">pm_cov_est</a> (PM_TYPE err, double *c11, double *c12, double *c22, double *c33, bool corridor=false, PM_TYPE corr_angle=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Estimates the covariance matrix of a match.  <a href="#29790780aad473173713c4c4761e55fe"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#866527b758dfd15cb80dfad741236e8a">pm_unit_test</a> (int matching_alg=PM_PSM, bool interactive=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs unit tests on scan matching.  <a href="#866527b758dfd15cb80dfad741236e8a"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#7adf181555b46e4183065f12259d7833">pm_fi</a> [PM_L_POINTS]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains precomputed range bearings.  <a href="#7adf181555b46e4183065f12259d7833"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#186431107f8c86b96cf50496db0034b6">pm_si</a> [PM_L_POINTS]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains the sinus of each bearing.  <a href="#186431107f8c86b96cf50496db0034b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#77175495995129afb08803552007f8a4">pm_co</a> [PM_L_POINTS]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains the cosinus of each bearing.  <a href="#77175495995129afb08803552007f8a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#de428e835e8cfeb0e14e46d7e5dc579d">PM_D2R</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Conversion factor for converting degrees to radians.  <a href="#de428e835e8cfeb0e14e46d7e5dc579d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8h.html#38ae4ea2ec6736ca50b08230452430f9">PM_R2D</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Conversion factor for converting radians to degrees.  <a href="#38ae4ea2ec6736ca50b08230452430f9"></a><br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="e672ca4e6355c247d2374b08c9985b0a"></a><!-- doxytag: member="polar_match.h::PM_CHANGE_WEIGHT_ITER" ref="e672ca4e6355c247d2374b08c9985b0a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_CHANGE_WEIGHT_ITER&nbsp;&nbsp;&nbsp;10          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of iterations after which the weighting factor is reduced to weight down outliers. 
<p>

</div>
</div><p>
<a class="anchor" name="12ef0a402ef7b41d2c9fc743d6323aa2"></a><!-- doxytag: member="polar_match.h::PM_CORRIDOR_THRESHOLD" ref="12ef0a402ef7b41d2c9fc743d6323aa2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_CORRIDOR_THRESHOLD&nbsp;&nbsp;&nbsp;25.0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Threshold for angle variation between points to determine if scan was taken of a corridor. 
<p>

</div>
</div><p>
<a class="anchor" name="7c8557515b1efc22da1f066ea3f539f1"></a><!-- doxytag: member="polar_match.h::PM_EMPTY" ref="7c8557515b1efc22da1f066ea3f539f1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_EMPTY&nbsp;&nbsp;&nbsp;16          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Measurement tag: no measurment (between 2 segments there is no interpolation!). 
<p>

</div>
</div><p>
<a class="anchor" name="9e29b0d21c905b7aa10cebcd439f1a8b"></a><!-- doxytag: member="polar_match.h::PM_FOV" ref="9e29b0d21c905b7aa10cebcd439f1a8b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_FOV&nbsp;&nbsp;&nbsp;270          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Field of view of the laser range finder in degrees. 
<p>

</div>
</div><p>
<a class="anchor" name="88446d4afac7a19b554b1ef7351e00d5"></a><!-- doxytag: member="polar_match.h::PM_HOKUYO_URG_04LX" ref="88446d4afac7a19b554b1ef7351e00d5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_HOKUYO_URG_04LX&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="20c80bf5ce369e4af70df4bc86991b27"></a><!-- doxytag: member="polar_match.h::PM_HOKUYO_UTM_30LX" ref="20c80bf5ce369e4af70df4bc86991b27" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_HOKUYO_UTM_30LX&nbsp;&nbsp;&nbsp;3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="8d5edbed38016249ada2530b04d7db88"></a><!-- doxytag: member="polar_match.h::PM_ICP" ref="8d5edbed38016249ada2530b04d7db88" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_ICP&nbsp;&nbsp;&nbsp;3          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Scan matching with iterative closest point association rule. 
<p>

</div>
</div><p>
<a class="anchor" name="fbd71471c9ea93ba0bdef75c051cb261"></a><!-- doxytag: member="polar_match.h::PM_L_POINTS" ref="fbd71471c9ea93ba0bdef75c051cb261" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_L_POINTS&nbsp;&nbsp;&nbsp;1081          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum number of points in a scan. 
<p>

</div>
</div><p>
<a class="anchor" name="b5589c1a2ace1e70b8e33f42111c11c0"></a><!-- doxytag: member="polar_match.h::PM_LASER" ref="b5589c1a2ace1e70b8e33f42111c11c0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_LASER&nbsp;&nbsp;&nbsp;PM_HOKUYO_UTM_30LX          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="6fc025e7dda64669c01c2742b377e7bb"></a><!-- doxytag: member="polar_match.h::PM_LASER_NAME" ref="6fc025e7dda64669c01c2742b377e7bb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_LASER_NAME&nbsp;&nbsp;&nbsp;&quot;HOKUYO UTM-30LX&quot;          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The name of the laser range finder. 
<p>

</div>
</div><p>
<a class="anchor" name="cb686990f0e3ce35b264c05c9062b63a"></a><!-- doxytag: member="polar_match.h::PM_LASER_Y" ref="cb686990f0e3ce35b264c05c9062b63a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_LASER_Y&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[cm] Y coordinate of the laser on the robot. 
<p>
Set to 0 for ground thruth, simulation, mapping_with_matching. Set to 0 when in doubt and handle the coordinate transforms yourself. Set it to 31.3 for Slambot. The Y axis points in the forward motion direction of a differential drive robot. 
</div>
</div><p>
<a class="anchor" name="127cb0f2f4998aa37f8193aa6804d58c"></a><!-- doxytag: member="polar_match.h::PM_MATCH_ERROR_OFFSET" ref="127cb0f2f4998aa37f8193aa6804d58c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_MATCH_ERROR_OFFSET&nbsp;&nbsp;&nbsp;5.0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[cm] Offset subtracted from average range residual when scaling the covariance matrix. 
<p>

</div>
</div><p>
<a class="anchor" name="ac716ccdca73689fc1d4d29117c6d816"></a><!-- doxytag: member="polar_match.h::PM_MAX_ERROR" ref="ac716ccdca73689fc1d4d29117c6d816" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_MAX_ERROR&nbsp;&nbsp;&nbsp;100          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[cm] Maximum distance between associated points used in pose estimation. Try setting it to 30 for laser odometry. 
<p>

</div>
</div><p>
<a class="anchor" name="24a5a1c6ca5fc964a95f9c8d66321a1c"></a><!-- doxytag: member="polar_match.h::PM_MAX_ITER" ref="24a5a1c6ca5fc964a95f9c8d66321a1c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_MAX_ITER&nbsp;&nbsp;&nbsp;30          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum number of iterations for PSM. 
<p>

</div>
</div><p>
<a class="anchor" name="0989a364bb66d542863ebea24374be59"></a><!-- doxytag: member="polar_match.h::PM_MAX_ITER_ICP" ref="0989a364bb66d542863ebea24374be59" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_MAX_ITER_ICP&nbsp;&nbsp;&nbsp;60          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Maximum number of iterations for ICP. 
<p>

</div>
</div><p>
<a class="anchor" name="ddeab933b14db8ee4ec85c5001e9e1b6"></a><!-- doxytag: member="polar_match.h::PM_MAX_RANGE" ref="ddeab933b14db8ee4ec85c5001e9e1b6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_MAX_RANGE&nbsp;&nbsp;&nbsp;700          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[cm] Maximum valid laser range. (3000 for this sensor.) 
<p>

</div>
</div><p>
<a class="anchor" name="79987f669fd90361ff94eaf778709f37"></a><!-- doxytag: member="polar_match.h::PM_MIN_RANGE" ref="79987f669fd90361ff94eaf778709f37" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_MIN_RANGE&nbsp;&nbsp;&nbsp;10.0f          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[cm] Minimum valid laser range for the reprojected current scan. 
<p>

</div>
</div><p>
<a class="anchor" name="e44b85502998a44b561543470ecd14d0"></a><!-- doxytag: member="polar_match.h::PM_MIN_STD_ORIENTATION" ref="e44b85502998a44b561543470ecd14d0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_MIN_STD_ORIENTATION&nbsp;&nbsp;&nbsp;4.0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[degrees] The minimum standard deviation of the orientation match. Used in covariance estimation. 
<p>

</div>
</div><p>
<a class="anchor" name="749734da50c3898c95b6570472fcdd84"></a><!-- doxytag: member="polar_match.h::PM_MIN_STD_XY" ref="749734da50c3898c95b6570472fcdd84" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_MIN_STD_XY&nbsp;&nbsp;&nbsp;20.0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[cm] The minimum match result standard deviation in X or Y direction. Used in covariance estimation. 
<p>

</div>
</div><p>
<a class="anchor" name="5f67e7016ad1a22a1b3d3d4c3a2daf09"></a><!-- doxytag: member="polar_match.h::PM_MIN_VALID_POINTS" ref="5f67e7016ad1a22a1b3d3d4c3a2daf09" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_MIN_VALID_POINTS&nbsp;&nbsp;&nbsp;300          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Minimum number of valid points for scan matching. 
<p>

</div>
</div><p>
<a class="anchor" name="9c63390241a1996a375113e70818480f"></a><!-- doxytag: member="polar_match.h::PM_MIXED" ref="9c63390241a1996a375113e70818480f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_MIXED&nbsp;&nbsp;&nbsp;4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Measurement tag: range reading is a mixed pixel. 
<p>

</div>
</div><p>
<a class="anchor" name="9b68094f2b71d03bdfb392053de3e037"></a><!-- doxytag: member="polar_match.h::PM_MOVING" ref="9b68094f2b71d03bdfb392053de3e037" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_MOVING&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Measurement tag: range reading corresponds to a moving point. Not implemented yet. 
<p>

</div>
</div><p>
<a class="anchor" name="514dcb3d8e039386047654eb3de7b4f8"></a><!-- doxytag: member="polar_match.h::PM_OCCLUDED" ref="514dcb3d8e039386047654eb3de7b4f8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_OCCLUDED&nbsp;&nbsp;&nbsp;8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Measurement tag: range reading is occluded. 
<p>

</div>
</div><p>
<a class="anchor" name="1b47ca281afd6f25bd2a0536090a073b"></a><!-- doxytag: member="polar_match.h::PM_ODO" ref="1b47ca281afd6f25bd2a0536090a073b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_ODO&nbsp;&nbsp;&nbsp;-1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Show results with odometry only in mapping_with_matching(). 
<p>

</div>
</div><p>
<a class="anchor" name="1f1545ae657e3e45bd93e57f9df9a774"></a><!-- doxytag: member="polar_match.h::PM_PSD_SCANNER" ref="1f1545ae657e3e45bd93e57f9df9a774" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_PSD_SCANNER&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="ef58bcd878269c2d222a0ecc2ec5232d"></a><!-- doxytag: member="polar_match.h::PM_PSM" ref="ef58bcd878269c2d222a0ecc2ec5232d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_PSM&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Polar scan matching - matching bearing association rule. 
<p>

</div>
</div><p>
<a class="anchor" name="57fe2d06df1606362b8af182164f1ca3"></a><!-- doxytag: member="polar_match.h::PM_RANGE" ref="57fe2d06df1606362b8af182164f1ca3" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_RANGE&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Measurement tag: range reading is longer than PM_MAX_RANGE. 
<p>

</div>
</div><p>
<a class="anchor" name="c91b4de7ae597b94bcec1c4e42e45e4a"></a><!-- doxytag: member="polar_match.h::PM_SEARCH_WINDOW" ref="c91b4de7ae597b94bcec1c4e42e45e4a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_SEARCH_WINDOW&nbsp;&nbsp;&nbsp;200          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Half window size which is searched for correct orientation. 
<p>

</div>
</div><p>
<a class="anchor" name="d5632a2b540e35319931ca7d0e2170a0"></a><!-- doxytag: member="polar_match.h::PM_SEG_MAX_DIST" ref="d5632a2b540e35319931ca7d0e2170a0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_SEG_MAX_DIST&nbsp;&nbsp;&nbsp;20.0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The distance between points to break a segment. 
<p>

</div>
</div><p>
<a class="anchor" name="34dcc5c7fb9c2ee19db0e8441b353b0c"></a><!-- doxytag: member="polar_match.h::PM_SICK_LMS200" ref="34dcc5c7fb9c2ee19db0e8441b353b0c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_SICK_LMS200&nbsp;&nbsp;&nbsp;2          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="9455b77f912bb1a02edd45dec9481546"></a><!-- doxytag: member="polar_match.h::PM_STOP_COND" ref="9455b77f912bb1a02edd45dec9481546" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_STOP_COND&nbsp;&nbsp;&nbsp;0.4          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If the pose change (|dx|+|dy|+|dth|) is smaller than this PSM scan matching stops. 
<p>

</div>
</div><p>
<a class="anchor" name="1e71013204bc565a4b62a6a47926c2a8"></a><!-- doxytag: member="polar_match.h::PM_STOP_COND_ICP" ref="1e71013204bc565a4b62a6a47926c2a8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_STOP_COND_ICP&nbsp;&nbsp;&nbsp;0.1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stopping condition for ICP. The pose change has to be smaller than this. 
<p>

</div>
</div><p>
<a class="anchor" name="f1bad4201ab86ef3744a85d53b2ded50"></a><!-- doxytag: member="polar_match.h::PM_TIME_DELAY" ref="f1bad4201ab86ef3744a85d53b2ded50" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_TIME_DELAY&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
[s] Time delay (time registration error) in the laser measurements. Use 0.02 for SLAMbot. 
<p>

</div>
</div><p>
<a class="anchor" name="d3a56b8761c758c51c32c5b869f9c17b"></a><!-- doxytag: member="polar_match.h::PM_TIME_FILE" ref="d3a56b8761c758c51c32c5b869f9c17b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_TIME_FILE&nbsp;&nbsp;&nbsp;&quot;results/iterations.txt&quot;          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
When generating results, timing is data is saved into this file from the matching algorithms. i|time|ax|ay|ath[deg] is saved. Does not work in the moment. 
<p>

</div>
</div><p>
<a class="anchor" name="d51e4b68f66ac8b34eb967900cf88254"></a><!-- doxytag: member="polar_match.h::PM_TYPE" ref="d51e4b68f66ac8b34eb967900cf88254" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_TYPE&nbsp;&nbsp;&nbsp;float          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The variable type used in calculations. Change it to double for higher accuracy and lower speed. 
<p>

</div>
</div><p>
<a class="anchor" name="ee30602d40d89456b33d224ba8646f86"></a><!-- doxytag: member="polar_match.h::PM_WEIGHTING_FACTOR" ref="ee30602d40d89456b33d224ba8646f86" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PM_WEIGHTING_FACTOR&nbsp;&nbsp;&nbsp;70*70          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parameter used for weighting associated points in the position calculation of PSM. Try setting it to 30*30 for laser odometry. 
<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="269e637afa67455e2a281485c2132cd1"></a><!-- doxytag: member="polar_match.h::pm_corridor_angle" ref="269e637afa67455e2a281485c2132cd1" args="(PMScan *act)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PM_TYPE pm_corridor_angle           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>act</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines the orientation of a corridor. 
<p>
TODO: NEEDS A REWRITE - TOO MESSY.<p>
Assuming the scan was taken of a corridor, determines the orientation of the corridor by finding the maximum in a 180 degree wide angle histogram. The input into the histogram are angles of lines created by connecting neighbouring points.<p>
Normally, this function is used on the reference scan and not the current scan.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>act</em>&nbsp;</td><td>The scan of which oriention is to be determined. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The orientation of the corridor. </dd></dl>

</div>
</div><p>
<a class="anchor" name="29790780aad473173713c4c4761e55fe"></a><!-- doxytag: member="polar_match.h::pm_cov_est" ref="29790780aad473173713c4c4761e55fe" args="(PM_TYPE err, double *c11, double *c12, double *c22, double *c33, bool corridor=false, PM_TYPE corr_angle=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_cov_est           </td>
          <td>(</td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>c11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>c12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>c22</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>c33</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>corridor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>corr_angle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Estimates the covariance matrix of a match. 
<p>
Estimates elements (c11,c12,c22,c33) of a match result covariance matrix of the following structure:<br>
 [c11 c12 0.0]<br>
 [c12 c22 0.0]<br>
 [0.0 0.0 c33]<br>
<p>
This function scales a base covariance matrix by an error index:<br>
 C = C0(PM_MIN_STD_XY, PM_MIN_STD_ORIENTATION) * (err - PM_MATCH_ERROR_OFFSET).<br>
 For corridors it scales and rotates a covariance matrix stretched in the direction of the corridor:<br>
 C = Rot(C0, corr_angle) * (err - PM_MATCH_ERROR_OFFSET).<br>
 If (err - PM_MATCH_ERROR_OFFSET) &lt; 1 then C = C0.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>The error index of the match. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c11,c12,c22,c33</em>&nbsp;</td><td>The estimated covariance matrix elements. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>corridor</em>&nbsp;</td><td>If true, a special estimate with large along-corridor-error is used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>corr_angle</em>&nbsp;</td><td>The orientation of the corridor. Call <em>pm_corridor_angle</em> on the refernce scan to get this value. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="90a35f8730af8bf63851a685506764ff"></a><!-- doxytag: member="polar_match.h::pm_error_index" ref="90a35f8730af8bf63851a685506764ff" args="(PMScan *lsr, PMScan *lsa)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PM_TYPE pm_error_index           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>lsr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>lsa</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates an error index expressing the quality of a match. 
<p>
This function assesses how well is the current scan aligned with the reference scan. This function has to be called after a scan has been matched. The current scan's pose has to be expressed in the reference scan's coordinate system.<p>
The current scan is compared to the reference scan and vice versa, then the maximum is taken. The comparisson is performed by calculating the average closest point distance. Far away points are ignored in the process. The number of non-far away points have to be larger than a threshold.<p>
This function is computationally very expensive and takes a conservative guess on the match quality.<p>
TODO: Improve the accuracy of the estimate. Speed it up. Perhaps should use the error output from scan matching instead. A proper test is necessary.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lsr</em>&nbsp;</td><td>The reference scan. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lra</em>&nbsp;</td><td>The current scan. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The average minimum Euclidean distance. </dd></dl>

</div>
</div><p>
<a class="anchor" name="afb41ec02d1003d39e2feabd15827a4a"></a><!-- doxytag: member="polar_match.h::pm_error_index2" ref="afb41ec02d1003d39e2feabd15827a4a" args="(PMScan *ref, PMScan *cur, int *associatedPoints=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PM_TYPE pm_error_index2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>cur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>associatedPoints</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
More quickly calculates an error index expressing the quality of a match. 
<p>
This function assesses how well is the current scan aligned with the reference scan. This function has to be called after a scan has been matched. The current scan's pose has to be expressed in the reference scan's coordinate system.<p>
The current scan is compared to the reference scan by projecting the current scan where the reference scan was taken and calculating the average range residuals.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lsr</em>&nbsp;</td><td>The reference scan. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lra</em>&nbsp;</td><td>The current scan. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The average minimum Euclidean distance. </dd></dl>

</div>
</div><p>
<a class="anchor" name="18792f0a29282b0365341e80ceb46681"></a><!-- doxytag: member="polar_match.h::pm_icp" ref="18792f0a29282b0365341e80ceb46681" args="(const PMScan *lsr, PMScan *lsa)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PM_TYPE pm_icp           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>lsr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>lsa</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Matches two laser scans using the iterative closest point method. 
<p>
Minimizes least square error of points through changing lsa-&gt;rx, lsa-&gt;ry, lsa-&gt;th by using ICP. It interpolates associated points. Only the best 80% of points are used in the pose calculation. Scan projection is done at each iteration.<p>
For maintanence reasons changed scan projection to that of psm. 
</div>
</div><p>
<a class="anchor" name="4947dafdc94654327c5205bddfa001dd"></a><!-- doxytag: member="polar_match.h::pm_init" ref="4947dafdc94654327c5205bddfa001dd" args="(const char *filename=NULL, FILE **fin=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_init           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE **&nbsp;</td>
          <td class="paramname"> <em>fin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialises internal variables and opens a log file. 
<p>
If filename is present, then it opens the scanfile and reads out the first line. The file pointer is then set to the corresponding file. Before performing any scan matching call this fuction once to initialize important global variables.<p>
Upon failure an exception is thrown.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>The name of the optional logfile to be used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fin</em>&nbsp;</td><td>The optional opened file pointer is returned here. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="af222f8943373c7a4a0bbc8f69d6fd72"></a><!-- doxytag: member="polar_match.h::pm_is_corridor" ref="af222f8943373c7a4a0bbc8f69d6fd72" args="(PMScan *act)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pm_is_corridor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>act</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Guesses if a scan was taken on a corridor. 
<p>
Scan matching results on corridors are often inaccurate in the along-corridor direction. By detecting scans with a corridor-like appearance one can tailor a covariance matrix to incorporate the along-corridor uncertainty of the scan matching result.<p>
Calculates the variance of angles between neighbouring Cartesian points as the "corridorness" criterion. On corridoors, the majority of vectors connecting neighbouring points are aligned along one line. Thus corridors generate a sharp peak in an angle histogram.<p>
To solve the problem caused at the 180-0 degree transition point the calculations are repeated after a 30 degree shift. This is a hack which can be fixed easily.<p>
The scan is assumed be pre-processed (segmentation and median filtering).<p>
An exeption is thrown if there is less than 1 valid point.<p>
TODO: Remove the double calculation of the variance. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>act</em>&nbsp;</td><td>The scan which is examined for being corridor-like. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if <em>act</em> seems to be taken of a corridor. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f9679379fd1436aff93ab8b4813983f4"></a><!-- doxytag: member="polar_match.h::pm_plotScan" ref="f9679379fd1436aff93ab8b4813983f4" args="(PMScan *ls, const char *col, double diameter=2.0, bool connect_lines=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_plotScan           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>ls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>diameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>connect_lines</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Plots scan <em>ls</em>. 
<p>
The scan is shifted by PM_LASER_Y. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ls</em>&nbsp;</td><td>The laser scan to be plotted at the scan's pose. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>col</em>&nbsp;</td><td>The colour of the scan as "red", "green"... See <em>dr_COLORS</em> for more. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>diameter</em>&nbsp;</td><td>[cm] The drawn diameter of the measured points. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>connect_lines</em>&nbsp;</td><td>If true, measured points are connected with lines. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="22eabc3feff28cd8fd8fb19571e6b675"></a><!-- doxytag: member="polar_match.h::pm_plotScan4Thesis" ref="22eabc3feff28cd8fd8fb19571e6b675" args="(PMScan *lsr, PMScan *lsa)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_plotScan4Thesis           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>lsr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>lsa</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Plots current and reference scan in the way scans appeared in my thesis. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lsr</em>&nbsp;</td><td>Reference scan. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lsa</em>&nbsp;</td><td>Current scan. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0e95edd6e41d0087202f9fadbc8ad396"></a><!-- doxytag: member="polar_match.h::pm_plotScanAt" ref="0e95edd6e41d0087202f9fadbc8ad396" args="(const PMScan *ls, PM_TYPE x, PM_TYPE y, PM_TYPE th, const char *col, double diameter=2.0, bool connect_lines=false)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_plotScanAt           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>ls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>diameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>connect_lines</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Plots scan <em>ls</em> at robot/laser pose <em>x</em>, <em>y</em>, <em>th</em>. 
<p>
The scan is shifted by PM_LASER_Y. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ls</em>&nbsp;</td><td>The laser scan to be plotted. The scan's pose is ignored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The X coordinate of the pose where the scan should be drawn. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The Y coordinate of the pose where the scan should be drawn. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>th</em>&nbsp;</td><td>The orientation coordinate of the pose where the scan should be drawn. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>col</em>&nbsp;</td><td>The colour of the scan as "red", "green"... See <em>dr_COLORS</em> for more. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>diameter</em>&nbsp;</td><td>[cm] The drawn diameter of the measured points. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>connect_lines</em>&nbsp;</td><td>If true, measured point are connected with lines. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="cb70907d3ce433306298dbef5641bc64"></a><!-- doxytag: member="polar_match.h::pm_plotTime4Thesis" ref="cb70907d3ce433306298dbef5641bc64" args="(PM_TYPE xt, PM_TYPE yt, PM_TYPE tht, int *iter=NULL, double *time=NULL)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_plotTime4Thesis           </td>
          <td>(</td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>xt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>yt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>tht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generates a convergence speed plot from previously saved result. 
<p>
If you want to see the convergence speed, then uncomment the definition of PM_GENERATE_RESULTS, recompile, match a scan and run this function.<p>
Only works if PM_GENERATE_RESULTS was enabled in the previous match as only then are results saved in a file which is read here. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xt</em>&nbsp;</td><td>The true X coordinate where the solution should converge. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>yt</em>&nbsp;</td><td>The true Y coordinate where the solution should converge. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tht</em>&nbsp;</td><td>[degrees] The true orientation where the solution should converge. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="748e87f2c5ded82e517d1bcd9fc7322b"></a><!-- doxytag: member="polar_match.h::pm_preprocessScan" ref="748e87f2c5ded82e517d1bcd9fc7322b" args="(PMScan *ls)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_preprocessScan           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>ls</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prepares a scan for scan matching. 
<p>
Filters the scan using median filter, finds far away points and segments the scan. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ls</em>&nbsp;</td><td>The scan to be preprocessed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a84d80a545d2ec2b25bdf2a6bfa5a862"></a><!-- doxytag: member="polar_match.h::pm_psm" ref="a84d80a545d2ec2b25bdf2a6bfa5a862" args="(const PMScan *lsr, PMScan *lsa)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PM_TYPE pm_psm           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>lsr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>lsa</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match two laser scans using polar scan matching. 
<p>
Minimizes the sum of square range residuals through changing lsa-&gt;rx, lsa-&gt;ry, lsa-&gt;th. The error is minimized by iterating a translation estimation step followed by an orientation search step.<p>
PSM was not explicitly designed for laser scan matching based odometry where scans with small pose difference are matched with each other without any prior pose information. However when using PSM for this purpose, reduce the values of PM_MAX_ERROR, PM_WEIGHTING_FACTOR to reflect the small inter-scan motion. Also by reducing the value of PM_STOP_COND, larger matching accuracy can be achieved. The currently implemented error estimation functions are not useful for laser odometry error estimation.<p>
Limitations: due to the nature of the association rule divergence in a slow rate may be experienced in rooms where there are not many features to constrain the solution in all directions. This can occur for examples in corridor-like environments including rooms where the room directly in front of the laser is outside of the range of the laser range finder.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lsr</em>&nbsp;</td><td>The reference scan. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lra</em>&nbsp;</td><td>The current scan. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f0959739b175ea5bee403844ec8fe348"></a><!-- doxytag: member="polar_match.h::pm_readScan" ref="f0959739b175ea5bee403844ec8fe348" args="(FILE *fin, PMScan *ls)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pm_readScan           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>ls</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads one scan from file <em>fin</em> and stores it in <em>ls</em>. 
<p>
Assumed data format: <br>
 time[s] x[m] y[m] theta[rad]<br>
 r0[cm]<br>
 r1[cm]<br>
 .<br>
 .<br>
 .<br>
 <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fin</em>&nbsp;</td><td>Pointer to the file opened with <a class="el" href="polar__match_8cpp.html#0f7e0f3dc45ce48e996e67146dacbc6e" title="Initialises internal variables and opens a log file.">pm_init()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ls</em>&nbsp;</td><td>The read laser scan is returned here. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns 0 on success, -1 if there are no more scans. </dd></dl>

</div>
</div><p>
<a class="anchor" name="da0c2b85d87b32706c919c721d8a7553"></a><!-- doxytag: member="polar_match.h::pm_save_scan" ref="da0c2b85d87b32706c919c721d8a7553" args="(PMScan *act, const char *filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_save_scan           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>act</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves scan in a text file. 
<p>
Saves the scan in the format of:<br>
 range[0] bad[0] segment[0] <br>
 range[1] bad[1] segment[1] <br>
 ...<br>
 The aim is to enable quick scan loading in Octave using the "scan=load(filename)"; command <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>act</em>&nbsp;</td><td>The scan to be saved. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>filenam</em>&nbsp;</td><td>The name of the file the scan is saved under. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="09ec80e246f96fea1d9384164824c8a3"></a><!-- doxytag: member="polar_match.h::pm_show_segmentation" ref="09ec80e246f96fea1d9384164824c8a3" args="(const PMScan *ls)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_show_segmentation           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>ls</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shows segmentation results by plotting segments with different colours. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ls</em>&nbsp;</td><td>The scan to be plotted. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="866527b758dfd15cb80dfad741236e8a"></a><!-- doxytag: member="polar_match.h::pm_unit_test" ref="866527b758dfd15cb80dfad741236e8a" args="(int matching_alg=PM_PSM, bool interactive=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_unit_test           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>matching_alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>interactive</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs unit tests on scan matching. 
<p>
It will assert when compiled in debug mode. Currently the test are very basic (too high level). Should add more tests with time.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>matching_alg</em>&nbsp;</td><td>Specify the scan matching algorithm to be tested (PM_PSM, PM_ICP). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interactive</em>&nbsp;</td><td>If true, graphically display results. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="77175495995129afb08803552007f8a4"></a><!-- doxytag: member="polar_match.h::pm_co" ref="77175495995129afb08803552007f8a4" args="[PM_L_POINTS]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PM_TYPE <a class="el" href="polar__match_8h.html#77175495995129afb08803552007f8a4">pm_co</a>[PM_L_POINTS]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Contains the cosinus of each bearing. 
<p>

</div>
</div><p>
<a class="anchor" name="de428e835e8cfeb0e14e46d7e5dc579d"></a><!-- doxytag: member="polar_match.h::PM_D2R" ref="de428e835e8cfeb0e14e46d7e5dc579d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const PM_TYPE <a class="el" href="polar__match_8h.html#de428e835e8cfeb0e14e46d7e5dc579d">PM_D2R</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Conversion factor for converting degrees to radians. 
<p>

</div>
</div><p>
<a class="anchor" name="7adf181555b46e4183065f12259d7833"></a><!-- doxytag: member="polar_match.h::pm_fi" ref="7adf181555b46e4183065f12259d7833" args="[PM_L_POINTS]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PM_TYPE <a class="el" href="polar__match_8h.html#7adf181555b46e4183065f12259d7833">pm_fi</a>[PM_L_POINTS]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Contains precomputed range bearings. 
<p>

</div>
</div><p>
<a class="anchor" name="38ae4ea2ec6736ca50b08230452430f9"></a><!-- doxytag: member="polar_match.h::PM_R2D" ref="38ae4ea2ec6736ca50b08230452430f9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const PM_TYPE <a class="el" href="polar__match_8h.html#38ae4ea2ec6736ca50b08230452430f9">PM_R2D</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Conversion factor for converting radians to degrees. 
<p>

</div>
</div><p>
<a class="anchor" name="186431107f8c86b96cf50496db0034b6"></a><!-- doxytag: member="polar_match.h::pm_si" ref="186431107f8c86b96cf50496db0034b6" args="[PM_L_POINTS]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PM_TYPE <a class="el" href="polar__match_8h.html#186431107f8c86b96cf50496db0034b6">pm_si</a>[PM_L_POINTS]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Contains the sinus of each bearing. 
<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Sep 21 10:19:15 2010 for PolarScanMatching(PSM) by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
