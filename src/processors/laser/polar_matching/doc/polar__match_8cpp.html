<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>PolarScanMatching(PSM): polar_matching/polar_match.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.8 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>polar_matching/polar_match.cpp File Reference</h1><code>#include &lt;iostream&gt;</code><br>
<code>#include &lt;math.h&gt;</code><br>
<code>#include &lt;stdlib.h&gt;</code><br>
<code>#include &lt;string.h&gt;</code><br>
<code>#include &lt;assert.h&gt;</code><br>
<code>#include &quot;<a class="el" href="polar__match_8h-source.html">polar_match.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="draw_8h-source.html">draw.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#c3644f84794a8bfdacf39c4b2c2495fc">SQ</a>(x)&nbsp;&nbsp;&nbsp;((x)*(x))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#74e36bb4c1754c9a9fe04849e09391f2">INTERPOLATE_ICP</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#8b91ba6b07595612b1fc3dfde2e3a14f">pm_scan_project</a> (const <a class="el" href="structPMScan.html">PMScan</a> *act, PM_TYPE *new_r, int *new_bad)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs scan projection.  <a href="#8b91ba6b07595612b1fc3dfde2e3a14f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#732beb58b14a291dfb2162cc7895ed3e">pm_orientation_search</a> (const <a class="el" href="structPMScan.html">PMScan</a> *ref, const PM_TYPE *new_r, const int *new_bad)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs one iteration of orientation alignment of current scan.  <a href="#732beb58b14a291dfb2162cc7895ed3e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#768612ce3cc6ed36410bc019320199ed">pm_translation_estimation</a> (const <a class="el" href="structPMScan.html">PMScan</a> *ref, const PM_TYPE *new_r, const int *new_bad, PM_TYPE C, PM_TYPE *dx, PM_TYPE *dy)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Estimate the postion of the current scan with respect to a reference scan.  <a href="#768612ce3cc6ed36410bc019320199ed"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#2d31246c410f46807042ad231db8983e">pm_msec</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns thread runtime under Linux in milliseconds.  <a href="#2d31246c410f46807042ad231db8983e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#179bb36f3f362032dd4404a0aa8b39f3">norm_a</a> (PM_TYPE a)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Normalize angle.  <a href="#179bb36f3f362032dd4404a0aa8b39f3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#0f7e0f3dc45ce48e996e67146dacbc6e">pm_init</a> (const char *filename, FILE **fin)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialises internal variables and opens a log file.  <a href="#0f7e0f3dc45ce48e996e67146dacbc6e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#f0959739b175ea5bee403844ec8fe348">pm_readScan</a> (FILE *fin, <a class="el" href="structPMScan.html">PMScan</a> *ls)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads one scan from file <em>fin</em> and stores it in <em>ls</em>.  <a href="#f0959739b175ea5bee403844ec8fe348"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#9b46af0b735c752883fb5ac8e16b7fa3">pm_plotScanAt</a> (const <a class="el" href="structPMScan.html">PMScan</a> *ls, PM_TYPE x, PM_TYPE y, PM_TYPE th, const char *col, double diameter, bool connect_lines)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plots scan <em>ls</em> at robot/laser pose <em>x</em>, <em>y</em>, <em>th</em>.  <a href="#9b46af0b735c752883fb5ac8e16b7fa3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#4802660b0964aeb03f783c2da662a1f2">pm_plotScan</a> (<a class="el" href="structPMScan.html">PMScan</a> *ls, const char *col, double diameter, bool connect_lines)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plots scan <em>ls</em>.  <a href="#4802660b0964aeb03f783c2da662a1f2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#33a0ceb57f43a7eeb0ee4f0ac7fcdfd5">pm_median_filter</a> (<a class="el" href="structPMScan.html">PMScan</a> *ls)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Filters the laser ranges with a median filter.  <a href="#33a0ceb57f43a7eeb0ee4f0ac7fcdfd5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#322e9c336d65e53ff8bae425bdf045d3">pm_segment_scan</a> (<a class="el" href="structPMScan.html">PMScan</a> *ls)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Segments scanpoints into groups based on range discontinuities.  <a href="#322e9c336d65e53ff8bae425bdf045d3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#2f1df9b60e70ef37ed76e8ea803b3ed2">pm_find_far_points</a> (<a class="el" href="structPMScan.html">PMScan</a> *ls)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tags point further than a given distance PM_MAX_RANGE.  <a href="#2f1df9b60e70ef37ed76e8ea803b3ed2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#09ec80e246f96fea1d9384164824c8a3">pm_show_segmentation</a> (const <a class="el" href="structPMScan.html">PMScan</a> *ls)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Shows segmentation results by plotting segments with different colours.  <a href="#09ec80e246f96fea1d9384164824c8a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#748e87f2c5ded82e517d1bcd9fc7322b">pm_preprocessScan</a> (<a class="el" href="structPMScan.html">PMScan</a> *ls)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prepares a scan for scan matching.  <a href="#748e87f2c5ded82e517d1bcd9fc7322b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#af222f8943373c7a4a0bbc8f69d6fd72">pm_is_corridor</a> (<a class="el" href="structPMScan.html">PMScan</a> *act)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Guesses if a scan was taken on a corridor.  <a href="#af222f8943373c7a4a0bbc8f69d6fd72"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#90a35f8730af8bf63851a685506764ff">pm_error_index</a> (<a class="el" href="structPMScan.html">PMScan</a> *lsr, <a class="el" href="structPMScan.html">PMScan</a> *lsa)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates an error index expressing the quality of a match.  <a href="#90a35f8730af8bf63851a685506764ff"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#8a45a7dfd0a27cb37fa9defb046d0cd1">pm_error_index2</a> (<a class="el" href="structPMScan.html">PMScan</a> *ref, <a class="el" href="structPMScan.html">PMScan</a> *cur, int *associatedPoints)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">More quickly calculates an error index expressing the quality of a match.  <a href="#8a45a7dfd0a27cb37fa9defb046d0cd1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#269e637afa67455e2a281485c2132cd1">pm_corridor_angle</a> (<a class="el" href="structPMScan.html">PMScan</a> *act)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines the orientation of a corridor.  <a href="#269e637afa67455e2a281485c2132cd1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#bc19e91958ea7d076a589667267e0df8">pm_cov_est</a> (PM_TYPE err, double *c11, double *c12, double *c22, double *c33, bool corridor, PM_TYPE corr_angle)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Estimates the covariance matrix of a match.  <a href="#bc19e91958ea7d076a589667267e0df8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#a84d80a545d2ec2b25bdf2a6bfa5a862">pm_psm</a> (const <a class="el" href="structPMScan.html">PMScan</a> *lsr, <a class="el" href="structPMScan.html">PMScan</a> *lsa)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Match two laser scans using polar scan matching.  <a href="#a84d80a545d2ec2b25bdf2a6bfa5a862"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#a599cdd65996edc5c92868764bc29abd">point_line_distance</a> (PM_TYPE x1, PM_TYPE y1, PM_TYPE x2, PM_TYPE y2, PM_TYPE x3, PM_TYPE y3, PM_TYPE *x, PM_TYPE *y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the distance of a point from a line section.  <a href="#a599cdd65996edc5c92868764bc29abd"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#18792f0a29282b0365341e80ceb46681">pm_icp</a> (const <a class="el" href="structPMScan.html">PMScan</a> *lsr, <a class="el" href="structPMScan.html">PMScan</a> *lsa)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Matches two laser scans using the iterative closest point method.  <a href="#18792f0a29282b0365341e80ceb46681"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#da0c2b85d87b32706c919c721d8a7553">pm_save_scan</a> (<a class="el" href="structPMScan.html">PMScan</a> *act, const char *filename)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Saves scan in a text file.  <a href="#da0c2b85d87b32706c919c721d8a7553"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#22eabc3feff28cd8fd8fb19571e6b675">pm_plotScan4Thesis</a> (<a class="el" href="structPMScan.html">PMScan</a> *lsr, <a class="el" href="structPMScan.html">PMScan</a> *lsa)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Plots current and reference scan in the way scans appeared in my thesis.  <a href="#22eabc3feff28cd8fd8fb19571e6b675"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#e604d53b9bd9dc8f25e3730f68548696">pm_plotTime4Thesis</a> (PM_TYPE xt, PM_TYPE yt, PM_TYPE tht, int *iter, double *time)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Generates a convergence speed plot from previously saved result.  <a href="#e604d53b9bd9dc8f25e3730f68548696"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#533b4c811b32b4b868e1505ef5bfe643">pm_take_simulated_scan</a> (const PM_TYPE xl, const PM_TYPE yl, const PM_TYPE thl, <a class="el" href="structPMScan.html">PMScan</a> *ls, PM_TYPE wallDistLeft=150.0, PM_TYPE wallDistFront=200.0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Takes a scan in a simulated room.  <a href="#533b4c811b32b4b868e1505ef5bfe643"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#638c6a6597bfa0c9b8388d305a051b9b">pm_unit_test</a> (int matching_alg, bool interactive)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs unit tests on scan matching.  <a href="#638c6a6597bfa0c9b8388d305a051b9b"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#7adf181555b46e4183065f12259d7833">pm_fi</a> [PM_L_POINTS]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains precomputed range bearings.  <a href="#7adf181555b46e4183065f12259d7833"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#186431107f8c86b96cf50496db0034b6">pm_si</a> [PM_L_POINTS]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains the sinus of each bearing.  <a href="#186431107f8c86b96cf50496db0034b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#77175495995129afb08803552007f8a4">pm_co</a> [PM_L_POINTS]</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Contains the cosinus of each bearing.  <a href="#77175495995129afb08803552007f8a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#de428e835e8cfeb0e14e46d7e5dc579d">PM_D2R</a> = M_PI/180.0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Conversion factor for converting degrees to radians.  <a href="#de428e835e8cfeb0e14e46d7e5dc579d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#38ae4ea2ec6736ca50b08230452430f9">PM_R2D</a> = 180.0/M_PI</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Conversion factor for converting radians to degrees.  <a href="#38ae4ea2ec6736ca50b08230452430f9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#b202d742131cad233f668fbf106ec228">PM_FI_MIN</a> = M_PI/2.0 - PM_FOV*<a class="el" href="polar__match_8h.html#de428e835e8cfeb0e14e46d7e5dc579d">PM_D2R</a>/2.0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#b2f2f5a0fb820a0f31c69798a769c128">PM_FI_MAX</a> = M_PI/2.0 + PM_FOV*<a class="el" href="polar__match_8h.html#de428e835e8cfeb0e14e46d7e5dc579d">PM_D2R</a>/2.0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">const PM_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="polar__match_8cpp.html#b52d4e33fb58c570d34174dc8332e476">PM_DFI</a> = PM_FOV*<a class="el" href="polar__match_8h.html#de428e835e8cfeb0e14e46d7e5dc579d">PM_D2R</a>/ ( PM_L_POINTS + 1.0 )</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="74e36bb4c1754c9a9fe04849e09391f2"></a><!-- doxytag: member="polar_match.cpp::INTERPOLATE_ICP" ref="74e36bb4c1754c9a9fe04849e09391f2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INTERPOLATE_ICP          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="c3644f84794a8bfdacf39c4b2c2495fc"></a><!-- doxytag: member="polar_match.cpp::SQ" ref="c3644f84794a8bfdacf39c4b2c2495fc" args="(x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SQ          </td>
          <td>(</td>
          <td class="paramtype">x&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td>&nbsp;&nbsp;&nbsp;((x)*(x))</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="179bb36f3f362032dd4404a0aa8b39f3"></a><!-- doxytag: member="polar_match.cpp::norm_a" ref="179bb36f3f362032dd4404a0aa8b39f3" args="(PM_TYPE a)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PM_TYPE norm_a           </td>
          <td>(</td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>a</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Normalize angle. 
<p>
Normalize angle to be within [-pi,pi).<p>
TODO: Make more efficient. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>a</em>&nbsp;</td><td>The angle to be normalized. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="269e637afa67455e2a281485c2132cd1"></a><!-- doxytag: member="polar_match.cpp::pm_corridor_angle" ref="269e637afa67455e2a281485c2132cd1" args="(PMScan *act)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PM_TYPE pm_corridor_angle           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>act</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines the orientation of a corridor. 
<p>
TODO: NEEDS A REWRITE - TOO MESSY.<p>
Assuming the scan was taken of a corridor, determines the orientation of the corridor by finding the maximum in a 180 degree wide angle histogram. The input into the histogram are angles of lines created by connecting neighbouring points.<p>
Normally, this function is used on the reference scan and not the current scan.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>act</em>&nbsp;</td><td>The scan of which oriention is to be determined. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The orientation of the corridor. </dd></dl>

</div>
</div><p>
<a class="anchor" name="bc19e91958ea7d076a589667267e0df8"></a><!-- doxytag: member="polar_match.cpp::pm_cov_est" ref="bc19e91958ea7d076a589667267e0df8" args="(PM_TYPE err, double *c11, double *c12, double *c22, double *c33, bool corridor, PM_TYPE corr_angle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_cov_est           </td>
          <td>(</td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>c11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>c12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>c22</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>c33</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>corridor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>corr_angle</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Estimates the covariance matrix of a match. 
<p>
Estimates elements (c11,c12,c22,c33) of a match result covariance matrix of the following structure:<br>
 [c11 c12 0.0]<br>
 [c12 c22 0.0]<br>
 [0.0 0.0 c33]<br>
<p>
This function scales a base covariance matrix by an error index:<br>
 C = C0(PM_MIN_STD_XY, PM_MIN_STD_ORIENTATION) * (err - PM_MATCH_ERROR_OFFSET).<br>
 For corridors it scales and rotates a covariance matrix stretched in the direction of the corridor:<br>
 C = Rot(C0, corr_angle) * (err - PM_MATCH_ERROR_OFFSET).<br>
 If (err - PM_MATCH_ERROR_OFFSET) &lt; 1 then C = C0.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>err</em>&nbsp;</td><td>The error index of the match. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>c11,c12,c22,c33</em>&nbsp;</td><td>The estimated covariance matrix elements. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>corridor</em>&nbsp;</td><td>If true, a special estimate with large along-corridor-error is used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>corr_angle</em>&nbsp;</td><td>The orientation of the corridor. Call <em>pm_corridor_angle</em> on the refernce scan to get this value. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="90a35f8730af8bf63851a685506764ff"></a><!-- doxytag: member="polar_match.cpp::pm_error_index" ref="90a35f8730af8bf63851a685506764ff" args="(PMScan *lsr, PMScan *lsa)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PM_TYPE pm_error_index           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>lsr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>lsa</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculates an error index expressing the quality of a match. 
<p>
This function assesses how well is the current scan aligned with the reference scan. This function has to be called after a scan has been matched. The current scan's pose has to be expressed in the reference scan's coordinate system.<p>
The current scan is compared to the reference scan and vice versa, then the maximum is taken. The comparisson is performed by calculating the average closest point distance. Far away points are ignored in the process. The number of non-far away points have to be larger than a threshold.<p>
This function is computationally very expensive and takes a conservative guess on the match quality.<p>
TODO: Improve the accuracy of the estimate. Speed it up. Perhaps should use the error output from scan matching instead. A proper test is necessary.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lsr</em>&nbsp;</td><td>The reference scan. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lra</em>&nbsp;</td><td>The current scan. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The average minimum Euclidean distance. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8a45a7dfd0a27cb37fa9defb046d0cd1"></a><!-- doxytag: member="polar_match.cpp::pm_error_index2" ref="8a45a7dfd0a27cb37fa9defb046d0cd1" args="(PMScan *ref, PMScan *cur, int *associatedPoints)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PM_TYPE pm_error_index2           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>cur</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>associatedPoints</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
More quickly calculates an error index expressing the quality of a match. 
<p>
This function assesses how well is the current scan aligned with the reference scan. This function has to be called after a scan has been matched. The current scan's pose has to be expressed in the reference scan's coordinate system.<p>
The current scan is compared to the reference scan by projecting the current scan where the reference scan was taken and calculating the average range residuals.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lsr</em>&nbsp;</td><td>The reference scan. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lra</em>&nbsp;</td><td>The current scan. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The average minimum Euclidean distance. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2f1df9b60e70ef37ed76e8ea803b3ed2"></a><!-- doxytag: member="polar_match.cpp::pm_find_far_points" ref="2f1df9b60e70ef37ed76e8ea803b3ed2" args="(PMScan *ls)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_find_far_points           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>ls</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Tags point further than a given distance PM_MAX_RANGE. 
<p>
Far away points get tagged as <em>PM_RANGE</em>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ls</em>&nbsp;</td><td>The scan searched for far points. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="18792f0a29282b0365341e80ceb46681"></a><!-- doxytag: member="polar_match.cpp::pm_icp" ref="18792f0a29282b0365341e80ceb46681" args="(const PMScan *lsr, PMScan *lsa)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PM_TYPE pm_icp           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>lsr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>lsa</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Matches two laser scans using the iterative closest point method. 
<p>
Minimizes least square error of points through changing lsa-&gt;rx, lsa-&gt;ry, lsa-&gt;th by using ICP. It interpolates associated points. Only the best 80% of points are used in the pose calculation. Scan projection is done at each iteration.<p>
For maintanence reasons changed scan projection to that of psm. 
</div>
</div><p>
<a class="anchor" name="0f7e0f3dc45ce48e996e67146dacbc6e"></a><!-- doxytag: member="polar_match.cpp::pm_init" ref="0f7e0f3dc45ce48e996e67146dacbc6e" args="(const char *filename, FILE **fin)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_init           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE **&nbsp;</td>
          <td class="paramname"> <em>fin</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialises internal variables and opens a log file. 
<p>
If filename is present, then it opens the scanfile and reads out the first line. The file pointer is then set to the corresponding file. Before performing any scan matching call this fuction once to initialize important global variables.<p>
Upon failure an exception is thrown.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>filename</em>&nbsp;</td><td>The name of the optional logfile to be used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fin</em>&nbsp;</td><td>The optional opened file pointer is returned here. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="af222f8943373c7a4a0bbc8f69d6fd72"></a><!-- doxytag: member="polar_match.cpp::pm_is_corridor" ref="af222f8943373c7a4a0bbc8f69d6fd72" args="(PMScan *act)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool pm_is_corridor           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>act</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Guesses if a scan was taken on a corridor. 
<p>
Scan matching results on corridors are often inaccurate in the along-corridor direction. By detecting scans with a corridor-like appearance one can tailor a covariance matrix to incorporate the along-corridor uncertainty of the scan matching result.<p>
Calculates the variance of angles between neighbouring Cartesian points as the "corridorness" criterion. On corridoors, the majority of vectors connecting neighbouring points are aligned along one line. Thus corridors generate a sharp peak in an angle histogram.<p>
To solve the problem caused at the 180-0 degree transition point the calculations are repeated after a 30 degree shift. This is a hack which can be fixed easily.<p>
The scan is assumed be pre-processed (segmentation and median filtering).<p>
An exeption is thrown if there is less than 1 valid point.<p>
TODO: Remove the double calculation of the variance. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>act</em>&nbsp;</td><td>The scan which is examined for being corridor-like. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if <em>act</em> seems to be taken of a corridor. </dd></dl>

</div>
</div><p>
<a class="anchor" name="33a0ceb57f43a7eeb0ee4f0ac7fcdfd5"></a><!-- doxytag: member="polar_match.cpp::pm_median_filter" ref="33a0ceb57f43a7eeb0ee4f0ac7fcdfd5" args="(PMScan *ls)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_median_filter           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>ls</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Filters the laser ranges with a median filter. 
<p>
The job of this median filter is to remove chair and table legs which are likely to change position with time.<p>
The median filter helps to get rid of spurious data. If the median filter's window is 5, then 3 points need be close to each other to surrive the filtering. Chair legs taking 1 or 2 range readings will be removed.<p>
Do not use this function when fitting lines to laser scans!<p>
Median filter will round up corners.<p>
x,y coordinates of points are not upadted. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ls</em>&nbsp;</td><td>Laser scan to be filtered. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2d31246c410f46807042ad231db8983e"></a><!-- doxytag: member="polar_match.cpp::pm_msec" ref="2d31246c410f46807042ad231db8983e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double pm_msec           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns thread runtime under Linux in milliseconds. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>[ms] Thread run time. </dd></dl>

</div>
</div><p>
<a class="anchor" name="732beb58b14a291dfb2162cc7895ed3e"></a><!-- doxytag: member="polar_match.cpp::pm_orientation_search" ref="732beb58b14a291dfb2162cc7895ed3e" args="(const PMScan *ref, const PM_TYPE *new_r, const int *new_bad)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PM_TYPE pm_orientation_search           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PM_TYPE *&nbsp;</td>
          <td class="paramname"> <em>new_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>new_bad</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs one iteration of orientation alignment of current scan. 
<p>
Function estimating the orientation of the current scan represented with range readings <em>new_r</em> tagged with flags <em>new_bad</em> with respect to the reference scan <em>ref</em>.<p>
This function exploits that if the current and reference scan are taken at the same position, an orientation change of the current scan results in a left or right shift of the scan ranges.<p>
This function estimates the orientation by finding that shift which minimizes the difference between the current and ref. scan. The orientation estimate is then refined using interpolation by fitting a parabole to the maximum and its neighbours and finding the maximum.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ref</em>&nbsp;</td><td>The reference scan. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_r</em>&nbsp;</td><td>The interpolated ranges of the current scan. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_bad</em>&nbsp;</td><td>The tags corresponding to the new_r. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns the rotation of  in radians which minimize the sum of absolute range residuals. </dd></dl>

<p>
TODO: speed up by unrolling the loop, replace if with multiplication with 0 or 1/ use sse2 instructions...<p>
TODO: Find out when is it useful to check if delta &lt; PM_MAX_ERROR - why only for the UTM... 
</div>
</div><p>
<a class="anchor" name="4802660b0964aeb03f783c2da662a1f2"></a><!-- doxytag: member="polar_match.cpp::pm_plotScan" ref="4802660b0964aeb03f783c2da662a1f2" args="(PMScan *ls, const char *col, double diameter, bool connect_lines)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_plotScan           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>ls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>diameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>connect_lines</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Plots scan <em>ls</em>. 
<p>
The scan is shifted by PM_LASER_Y. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ls</em>&nbsp;</td><td>The laser scan to be plotted at the scan's pose. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>col</em>&nbsp;</td><td>The colour of the scan as "red", "green"... See <em>dr_COLORS</em> for more. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>diameter</em>&nbsp;</td><td>[cm] The drawn diameter of the measured points. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>connect_lines</em>&nbsp;</td><td>If true, measured points are connected with lines. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="22eabc3feff28cd8fd8fb19571e6b675"></a><!-- doxytag: member="polar_match.cpp::pm_plotScan4Thesis" ref="22eabc3feff28cd8fd8fb19571e6b675" args="(PMScan *lsr, PMScan *lsa)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_plotScan4Thesis           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>lsr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>lsa</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Plots current and reference scan in the way scans appeared in my thesis. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lsr</em>&nbsp;</td><td>Reference scan. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lsa</em>&nbsp;</td><td>Current scan. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9b46af0b735c752883fb5ac8e16b7fa3"></a><!-- doxytag: member="polar_match.cpp::pm_plotScanAt" ref="9b46af0b735c752883fb5ac8e16b7fa3" args="(const PMScan *ls, PM_TYPE x, PM_TYPE y, PM_TYPE th, const char *col, double diameter, bool connect_lines)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_plotScanAt           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>ls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>th</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>diameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>connect_lines</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Plots scan <em>ls</em> at robot/laser pose <em>x</em>, <em>y</em>, <em>th</em>. 
<p>
The scan is shifted by PM_LASER_Y. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ls</em>&nbsp;</td><td>The laser scan to be plotted. The scan's pose is ignored. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The X coordinate of the pose where the scan should be drawn. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The Y coordinate of the pose where the scan should be drawn. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>th</em>&nbsp;</td><td>The orientation coordinate of the pose where the scan should be drawn. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>col</em>&nbsp;</td><td>The colour of the scan as "red", "green"... See <em>dr_COLORS</em> for more. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>diameter</em>&nbsp;</td><td>[cm] The drawn diameter of the measured points. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>connect_lines</em>&nbsp;</td><td>If true, measured point are connected with lines. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e604d53b9bd9dc8f25e3730f68548696"></a><!-- doxytag: member="polar_match.cpp::pm_plotTime4Thesis" ref="e604d53b9bd9dc8f25e3730f68548696" args="(PM_TYPE xt, PM_TYPE yt, PM_TYPE tht, int *iter, double *time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_plotTime4Thesis           </td>
          <td>(</td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>xt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>yt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>tht</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generates a convergence speed plot from previously saved result. 
<p>
If you want to see the convergence speed, then uncomment the definition of PM_GENERATE_RESULTS, recompile, match a scan and run this function.<p>
Only works if PM_GENERATE_RESULTS was enabled in the previous match as only then are results saved in a file which is read here. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xt</em>&nbsp;</td><td>The true X coordinate where the solution should converge. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>yt</em>&nbsp;</td><td>The true Y coordinate where the solution should converge. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tht</em>&nbsp;</td><td>[degrees] The true orientation where the solution should converge. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="748e87f2c5ded82e517d1bcd9fc7322b"></a><!-- doxytag: member="polar_match.cpp::pm_preprocessScan" ref="748e87f2c5ded82e517d1bcd9fc7322b" args="(PMScan *ls)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_preprocessScan           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>ls</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Prepares a scan for scan matching. 
<p>
Filters the scan using median filter, finds far away points and segments the scan. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ls</em>&nbsp;</td><td>The scan to be preprocessed. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a84d80a545d2ec2b25bdf2a6bfa5a862"></a><!-- doxytag: member="polar_match.cpp::pm_psm" ref="a84d80a545d2ec2b25bdf2a6bfa5a862" args="(const PMScan *lsr, PMScan *lsa)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PM_TYPE pm_psm           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>lsr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>lsa</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Match two laser scans using polar scan matching. 
<p>
Minimizes the sum of square range residuals through changing lsa-&gt;rx, lsa-&gt;ry, lsa-&gt;th. The error is minimized by iterating a translation estimation step followed by an orientation search step.<p>
PSM was not explicitly designed for laser scan matching based odometry where scans with small pose difference are matched with each other without any prior pose information. However when using PSM for this purpose, reduce the values of PM_MAX_ERROR, PM_WEIGHTING_FACTOR to reflect the small inter-scan motion. Also by reducing the value of PM_STOP_COND, larger matching accuracy can be achieved. The currently implemented error estimation functions are not useful for laser odometry error estimation.<p>
Limitations: due to the nature of the association rule divergence in a slow rate may be experienced in rooms where there are not many features to constrain the solution in all directions. This can occur for examples in corridor-like environments including rooms where the room directly in front of the laser is outside of the range of the laser range finder.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>lsr</em>&nbsp;</td><td>The reference scan. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lra</em>&nbsp;</td><td>The current scan. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f0959739b175ea5bee403844ec8fe348"></a><!-- doxytag: member="polar_match.cpp::pm_readScan" ref="f0959739b175ea5bee403844ec8fe348" args="(FILE *fin, PMScan *ls)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int pm_readScan           </td>
          <td>(</td>
          <td class="paramtype">FILE *&nbsp;</td>
          <td class="paramname"> <em>fin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>ls</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads one scan from file <em>fin</em> and stores it in <em>ls</em>. 
<p>
Assumed data format: <br>
 time[s] x[m] y[m] theta[rad]<br>
 r0[cm]<br>
 r1[cm]<br>
 .<br>
 .<br>
 .<br>
 <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fin</em>&nbsp;</td><td>Pointer to the file opened with <a class="el" href="polar__match_8cpp.html#0f7e0f3dc45ce48e996e67146dacbc6e" title="Initialises internal variables and opens a log file.">pm_init()</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ls</em>&nbsp;</td><td>The read laser scan is returned here. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns 0 on success, -1 if there are no more scans. </dd></dl>

</div>
</div><p>
<a class="anchor" name="da0c2b85d87b32706c919c721d8a7553"></a><!-- doxytag: member="polar_match.cpp::pm_save_scan" ref="da0c2b85d87b32706c919c721d8a7553" args="(PMScan *act, const char *filename)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_save_scan           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>act</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>filename</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Saves scan in a text file. 
<p>
Saves the scan in the format of:<br>
 range[0] bad[0] segment[0] <br>
 range[1] bad[1] segment[1] <br>
 ...<br>
 The aim is to enable quick scan loading in Octave using the "scan=load(filename)"; command <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>act</em>&nbsp;</td><td>The scan to be saved. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>filenam</em>&nbsp;</td><td>The name of the file the scan is saved under. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8b91ba6b07595612b1fc3dfde2e3a14f"></a><!-- doxytag: member="polar_match.cpp::pm_scan_project" ref="8b91ba6b07595612b1fc3dfde2e3a14f" args="(const PMScan *act, PM_TYPE *new_r, int *new_bad)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_scan_project           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>act</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PM_TYPE *&nbsp;</td>
          <td class="paramname"> <em>new_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>new_bad</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs scan projection. 
<p>
This function enables the comparisson of two scans. It projects the current (active) scan <em>act</em> into the reference scans <em>ref</em> coordinate frame, using the current scan's pose. As the reference scan is assumed to be at the origin, its coordinates don't need to be passed along. Returns in new_r the interpolated range readinds r at the reference scan's measurement bearings. Returns in new_bad bad flags of the interpolated range readings, where occluded readings are tagged.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>act</em>&nbsp;</td><td>The current scan. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_r</em>&nbsp;</td><td>Array of the projected range readings (has to have the correct size). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_bad</em>&nbsp;</td><td>Information about the validity of the interpolated range readings is returned here. </td></tr>
  </table>
</dl>

<p>
TODO: replace this hack with proper fix where we don't loose points.<p>
TODO: Uncomment this? (or leave it as it is a local scan matching approach anyway) 
</div>
</div><p>
<a class="anchor" name="322e9c336d65e53ff8bae425bdf045d3"></a><!-- doxytag: member="polar_match.cpp::pm_segment_scan" ref="322e9c336d65e53ff8bae425bdf045d3" args="(PMScan *ls)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_segment_scan           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>ls</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Segments scanpoints into groups based on range discontinuities. 
<p>
By segmenting scans into groups of disconnected sets of points, one can prevent falsely interpolating points into the free space between disconnected objects during scan projection.<p>
Segment number 0 is reserved to segments containing only 1 point.<p>
Far away points (r &gt; PM_MAX_RANGE), gaps between groups of points - divide segments. The gap between extrapolated point and current point has to be large as well to prevent corridor walls to be segmented into separate points. 
</div>
</div><p>
<a class="anchor" name="09ec80e246f96fea1d9384164824c8a3"></a><!-- doxytag: member="polar_match.cpp::pm_show_segmentation" ref="09ec80e246f96fea1d9384164824c8a3" args="(const PMScan *ls)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_show_segmentation           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>ls</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Shows segmentation results by plotting segments with different colours. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ls</em>&nbsp;</td><td>The scan to be plotted. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="533b4c811b32b4b868e1505ef5bfe643"></a><!-- doxytag: member="polar_match.cpp::pm_take_simulated_scan" ref="533b4c811b32b4b868e1505ef5bfe643" args="(const PM_TYPE xl, const PM_TYPE yl, const PM_TYPE thl, PMScan *ls, PM_TYPE wallDistLeft=150.0, PM_TYPE wallDistFront=200.0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_take_simulated_scan           </td>
          <td>(</td>
          <td class="paramtype">const PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>xl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>yl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>thl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>ls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>wallDistLeft</em> = <code>150.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>wallDistFront</em> = <code>200.0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Takes a scan in a simulated room. 
<p>
The simulated room is just a rectangle. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>xl</em>&nbsp;</td><td>X coordinate of where the scan is taken. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>yl</em>&nbsp;</td><td>Y coordinate of where the scan is taken. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>thl</em>&nbsp;</td><td>Orientation with which the scan is taken. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>ls</em>&nbsp;</td><td>The laser range finder pose is read out from here, and the </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wallDistLeft</em>&nbsp;</td><td>[cm] The distance of the left and right wall from the centre. Optional. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wallDistFront</em>&nbsp;</td><td>[cm] The distance of the front and back wall from the centre. Optional. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="768612ce3cc6ed36410bc019320199ed"></a><!-- doxytag: member="polar_match.cpp::pm_translation_estimation" ref="768612ce3cc6ed36410bc019320199ed" args="(const PMScan *ref, const PM_TYPE *new_r, const int *new_bad, PM_TYPE C, PM_TYPE *dx, PM_TYPE *dy)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PM_TYPE pm_translation_estimation           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structPMScan.html">PMScan</a> *&nbsp;</td>
          <td class="paramname"> <em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PM_TYPE *&nbsp;</td>
          <td class="paramname"> <em>new_r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>new_bad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PM_TYPE *&nbsp;</td>
          <td class="paramname"> <em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PM_TYPE *&nbsp;</td>
          <td class="paramname"> <em>dy</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Estimate the postion of the current scan with respect to a reference scan. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ref</em>&nbsp;</td><td>The reference scan. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_r</em>&nbsp;</td><td>The interpolated ranges of the current scan. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>new_bad</em>&nbsp;</td><td>The tags corresponding to the new_r. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>C</em>&nbsp;</td><td>Weighting factor for range residuals. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dx</em>&nbsp;</td><td>Estimated position increment X coordinate is returned here. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dy</em>&nbsp;</td><td>Estimated position increment Y coordinate is returned here. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Returns the average range residual. </dd></dl>

</div>
</div><p>
<a class="anchor" name="638c6a6597bfa0c9b8388d305a051b9b"></a><!-- doxytag: member="polar_match.cpp::pm_unit_test" ref="638c6a6597bfa0c9b8388d305a051b9b" args="(int matching_alg, bool interactive)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pm_unit_test           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>matching_alg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>interactive</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Performs unit tests on scan matching. 
<p>
It will assert when compiled in debug mode. Currently the test are very basic (too high level). Should add more tests with time.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>matching_alg</em>&nbsp;</td><td>Specify the scan matching algorithm to be tested (PM_PSM, PM_ICP). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>interactive</em>&nbsp;</td><td>If true, graphically display results. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a599cdd65996edc5c92868764bc29abd"></a><!-- doxytag: member="polar_match.cpp::point_line_distance" ref="a599cdd65996edc5c92868764bc29abd" args="(PM_TYPE x1, PM_TYPE y1, PM_TYPE x2, PM_TYPE y2, PM_TYPE x3, PM_TYPE y3, PM_TYPE *x, PM_TYPE *y)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PM_TYPE point_line_distance           </td>
          <td>(</td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PM_TYPE&nbsp;</td>
          <td class="paramname"> <em>y3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PM_TYPE *&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PM_TYPE *&nbsp;</td>
          <td class="paramname"> <em>y</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Calculate the distance of a point from a line section. 
<p>
Calculates the distance of the point (x3,y3) from a line defined by (x1,y1) and (x2,y2). Returns the distance to the line or -1 if the projection of (x3,y3) falls outside the line segment defined by (x1,y1) and (x2,y2). The projection of (x3,y3) onto the line is also returned in x,y. This function is used in ICP. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x1,y1</em>&nbsp;</td><td>The start point of the line section. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x2,y2</em>&nbsp;</td><td>The end point of the line section. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x3,y3</em>&nbsp;</td><td>The point of which distance it sought. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>x,y</em>&nbsp;</td><td>(x3,y3) projected onto the line segment is returned here. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The distance from the line or -1 if the projection falls outside of the line segment. </dd></dl>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="77175495995129afb08803552007f8a4"></a><!-- doxytag: member="polar_match.cpp::pm_co" ref="77175495995129afb08803552007f8a4" args="[PM_L_POINTS]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PM_TYPE <a class="el" href="polar__match_8h.html#77175495995129afb08803552007f8a4">pm_co</a>[PM_L_POINTS]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Contains the cosinus of each bearing. 
<p>

</div>
</div><p>
<a class="anchor" name="de428e835e8cfeb0e14e46d7e5dc579d"></a><!-- doxytag: member="polar_match.cpp::PM_D2R" ref="de428e835e8cfeb0e14e46d7e5dc579d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const PM_TYPE <a class="el" href="polar__match_8h.html#de428e835e8cfeb0e14e46d7e5dc579d">PM_D2R</a> = M_PI/180.0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Conversion factor for converting degrees to radians. 
<p>

</div>
</div><p>
<a class="anchor" name="b52d4e33fb58c570d34174dc8332e476"></a><!-- doxytag: member="polar_match.cpp::PM_DFI" ref="b52d4e33fb58c570d34174dc8332e476" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const PM_TYPE <a class="el" href="polar__match_8cpp.html#b52d4e33fb58c570d34174dc8332e476">PM_DFI</a> = PM_FOV*<a class="el" href="polar__match_8h.html#de428e835e8cfeb0e14e46d7e5dc579d">PM_D2R</a>/ ( PM_L_POINTS + 1.0 )          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="7adf181555b46e4183065f12259d7833"></a><!-- doxytag: member="polar_match.cpp::pm_fi" ref="7adf181555b46e4183065f12259d7833" args="[PM_L_POINTS]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PM_TYPE <a class="el" href="polar__match_8h.html#7adf181555b46e4183065f12259d7833">pm_fi</a>[PM_L_POINTS]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Contains precomputed range bearings. 
<p>

</div>
</div><p>
<a class="anchor" name="b2f2f5a0fb820a0f31c69798a769c128"></a><!-- doxytag: member="polar_match.cpp::PM_FI_MAX" ref="b2f2f5a0fb820a0f31c69798a769c128" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const PM_TYPE <a class="el" href="polar__match_8cpp.html#b2f2f5a0fb820a0f31c69798a769c128">PM_FI_MAX</a> = M_PI/2.0 + PM_FOV*<a class="el" href="polar__match_8h.html#de428e835e8cfeb0e14e46d7e5dc579d">PM_D2R</a>/2.0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="b202d742131cad233f668fbf106ec228"></a><!-- doxytag: member="polar_match.cpp::PM_FI_MIN" ref="b202d742131cad233f668fbf106ec228" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const PM_TYPE <a class="el" href="polar__match_8cpp.html#b202d742131cad233f668fbf106ec228">PM_FI_MIN</a> = M_PI/2.0 - PM_FOV*<a class="el" href="polar__match_8h.html#de428e835e8cfeb0e14e46d7e5dc579d">PM_D2R</a>/2.0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>

</div>
</div><p>
<a class="anchor" name="38ae4ea2ec6736ca50b08230452430f9"></a><!-- doxytag: member="polar_match.cpp::PM_R2D" ref="38ae4ea2ec6736ca50b08230452430f9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const PM_TYPE <a class="el" href="polar__match_8h.html#38ae4ea2ec6736ca50b08230452430f9">PM_R2D</a> = 180.0/M_PI          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Conversion factor for converting radians to degrees. 
<p>

</div>
</div><p>
<a class="anchor" name="186431107f8c86b96cf50496db0034b6"></a><!-- doxytag: member="polar_match.cpp::pm_si" ref="186431107f8c86b96cf50496db0034b6" args="[PM_L_POINTS]" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PM_TYPE <a class="el" href="polar__match_8h.html#186431107f8c86b96cf50496db0034b6">pm_si</a>[PM_L_POINTS]          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Contains the sinus of each bearing. 
<p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Tue Sep 21 10:19:15 2010 for PolarScanMatching(PSM) by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.8 </small></address>
</body>
</html>
